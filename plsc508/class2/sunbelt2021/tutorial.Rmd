---
title: "Tutorial 1"
author: "Joseph Risi"
date: "2022-08-25"
output: pdf_document
---

## Introduction to igraph

```{r}
library(igraph)
library(readr)
library(here)
library(dplyr)
```

We will convert the raw data to an igraph network object. To do that, we will use the graph_from_data_frame() function, which takes two data frames: d and vertices.

* *d* describes the edges of the network. Its first two columns are the IDs of the source and the target node for each edge. The following columns are edge attributes (weight, type, label, or anything else).
* *vertices* starts with a column of node IDs. Any following columns are interpreted as node attributes.

```{r}
nodes <- read_csv(here("class2",
                       "sunbelt2021",
                       "Data files",
                       "Dataset1-Media-Example-NODES.csv"))

links <- read_csv(here("class2",
                       "sunbelt2021",
                       "Data files",
                       "Dataset1-Media-Example-EDGES.csv"))

net <- graph_from_data_frame(d = links, vertices = nodes, directed = T)
```

The description of an igraph object starts with four letters:

* D or U, for a directed or undirected graph
* N for a named graph (where nodes have a name attribute)
* W for a weighted graph (where edges have a weight attribute)
* B for a bipartite (two-mode) graph (where nodes have a type attribute)

The two numbers that follow (17 49) refer to the number of nodes and edges in the graph. The description also lists node & edge attributes, for example:

* (g/c) - graph-level character attribute
* (v/c) - vertex-level character attribute
* (e/n) - edge-level numeric attribute

```{r}
E(net)       # The edges of the "net" object
V(net)       # The vertices of the "net" object
E(net)$type  # Edge attribute "type"
V(net)$media # Vertex attribute "media"

# We can get back the vertex ids
V(net)$name

# Find nodes and edges by attribute:
# (that returns oblects of type vertex sequence/edge sequence)
V(net)[media == "BBC"]
E(net)[type == "mention"]

# You can also examine the network matrix directly:
net[1,]
net[5, 7]
```

Extract the edge list or adjacency matrix.

```{r}
# Get an edge list or a matrix:
as_edgelist(net, names = T)
as_adjacency_matrix(net, attr = "weight")

# Or data frames describing nodes and edges:
igraph::as_data_frame(net, what = "edges")
igraph::as_data_frame(net, what = "vertices")
```

A simple graph is a graph with no loops and no multiple edges. It is important to note that we are not fully simplifying our graph because we want to keep multiple edges. See here https://kateto.net/network-visualization for some nice visualizations on simplifying a graph.

```{r}
net <- simplify(net, remove.multiple = F, remove.loops = T)
plot(net, edge.arrow.size = 0.4, vertex.label = NA)
```

Notice how the links2 data set is not an edge list but an adjacency matrix. This is a two-mode graph looking at the links between news sources and their consumers. Two-mode graphs or bipartite graphs (in igraph) have a node attribute called type that is FALSE (or 0) for vertices in one mode and TRUE (or 1) for those in the other mode.

To transform a one-mode network matrix into an igraph object, use graph_from_adjacency_matrix().

```{r}
nodes2 <- read_csv(here("class2",
                        "sunbelt2021",
                        "Data files",
                        "Dataset2-Media-User-Example-NODES.csv"))

links2 <- read_csv(here("class2",
                        "sunbelt2021",
                        "Data files",
                        "Dataset2-Media-User-Example-EDGES.csv"))

net2 <- graph_from_incidence_matrix(links2)
```

## Plotting our graphs from igraph

We can set up plotting options in one of two ways.

### Option 1

Specify them in the plot function.

```{r}
plot(net, edge.arrow.size=.2, edge.color="orange", edge.curved = 0.1,
     vertex.color="orange", vertex.frame.color="#ffffff",
     vertex.label=V(net)$media, vertex.label.color="black")
```

### Option 2

Add them to the igraph object.
What are network layouts? They are algorithms for how to layout your graph! https://igraph.org/c/doc/igraph-Layout.html

```{r}
# The labels are currently node IDs.
# Setting them to NA will render no labels:
V(net)$label <- NA

# Generate colors based on media type
# NOTE this only works because media.type is an integer value
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]

# change arrow size and edge color:
E(net)$arrow.size <- 0.1
E(net)$edge.color <- "gray80"

netB <- net
netC <- net

# Compute node degrees (#links) and use that to set node size:
deg <- degree(net, mode = "all")
V(net)$size <- deg * 3
V(netC)$size <- deg * 3

# We could also use the audience size value:
V(netB)$size <- V(net)$audience.size * 0.6

# Set edge width based on weight:
E(netB)$width <- E(net)$weight / 4

# We can even set the network layout:
graph_attr(netC, "layout") <- layout_with_lgl

plot(net)
legend(x=-1.5, y=-1.1, c("Newspaper","Television", "Online News"),
       pt.bg = colrs, pch = 21)
plot(netB)
plot(netC)
```

We can color edges based on their source node. The ends function is used to determine the starting node for some set of edges in a graph. We select the first column to get the source node. The second column is the origin node.

Notice how ends returns a list of indices. This is why we can also identify their colors easily.

```{r}
edge.start <- ends(net, es = E(net), names = F)[, 1]
edge.col <- V(net)$color[edge.start]

plot(net, edge.color = edge.col, edge.curved = 0.1)
```

### More on layouts

Notice how l is a matrix of x, y coordinates with N rows where N is the number of nodes in the graph. As a result, we can easily make our own layouts.

One popular layout is the Fruchterman-Reingold force-directed layout. Force-directed layouts try to get a nice-looking graph where edges are similar in length and cross each other as little as possible. They simulate the graph as a physical system. Nodes are electrically charged particles that repulse each other when they get too close. The edges act as springs that attract connected nodes closer together. As a result, nodes are evenly distributed through the chart area, and the layout is intuitive in that nodes which share more connections are closer to each other. The disadvantage of these algorithms is that they are rather slow and therefore less often used in graphs larger than ~1000 vertices.

With force-directed layouts, you can use the niter parameter to control the number of iterations to perform. The default is set at 500 iterations. You can lower that number for large graphs to get results faster and check if they look reasonable.

The layout can also interpret edge weights. You can set the “weights” parameter which increases the attraction forces among nodes connected by heavier edges.

You will also notice that the Fruchterman-Reingold layout is not deterministic - different runs will result in slightly different configurations. Saving the layout in l allows us to get the exact same result multiple times, which can be helpful if you want to plot the time evolution of a graph, or different relationships – and want nodes to stay in the same place in multiple plots.

```{r}
plot(net, layout = layout_randomly)

l <- layout_in_circle(net)
plot(net, layout = l)

cust_l <- cbind(1:vcount(net), vcount(net):1)
plot(net, layout = cust_l)

l <- layout_with_fr(net)
plot(net, layout = l)

l2 <- layout_with_fr(net, niter = 50)
plot(net, layout = l2)

E(net)$width <- E(net)$weight / 4
l3 <- layout_with_fr(net, weights = E(net)$weight / 4)
plot(net, layout = l3)
```

From the tutorial. It is useful to learn about.

We use the sample_pa() function which generates a simple graph starting from one node and adding more nodes and links based on a preset level of preferential attachment (Barabasi-Albert model).

```{r}
net_sample <- sample_pa(100)
```

The tutorial also goes over other graph layouts which are commonly used like Kamada Kawai and Graphopt and the available parameters which can be tweaked for these layout algorithms.

### Making our graph visualizations more useful

One way we can make our visualization more useful is by deleting edges with low weight. There are many ways to identify what low weight is, but for our purposes we will be deleting edges with weight less than the mean.

In igraph, we can delete edges using delete_edges(net, edges).

```{r}
net_del <- delete_edges(net, E(net)[weight < mean(links$weight)])
plot(net_del, layout = layout_with_kk)
```

We can also show communities within the networked data.

```{r}
# Community detection (by optimizing modularity over partitions)
clp <- cluster_optimal(net)

# Community detection returns an object of class "communities" 
# which igraph knows how to plot
plot(clp, net)
 
# We can also plot the communities without relying on their built-in plot

# First create a new column and tell each vertex what community they're part of
V(net)$community <- clp$membership

# Adjust color allows us to control the transparency or alpha
colrs <- adjustcolor(c("gray50", "tomato", "gold", "yellowgreen"), alpha = 0.6)

plot(net, vertex.color = colrs[V(net)$community])
```

### Highlighting specific nodes or links

The *distances* function returns a matrix of shortest paths from nodes listed in the *v* parameter to ones included in the *to* parameter.

In our example, we are finding the shortest paths from the NY Times node to every other node.

We can generate our own gradients using `colorRampPalette`. Note that `colorRampPalette` returns a function that we can use to generate as many colors from that palette as we need.

```{r}
dist_from_NYT <- distances(net,
                           v = V(net)[media == "NY Times"], 
                           to = V(net),
                           weights = NA)

# Set colors to plot the distances
oranges <- colorRampPalette(c("dark red", "gold"))
col <- oranges(max(dist_from_NYT) + 1) # we add 1 since we start at 0
col <- col[dist_from_NYT + 1]

plot(net, vertex.color = col,
     vertex.label= dist_from_NYT,
     edge.arrow.size = 0.6, 
     vertex.label.color="white")
```

We can also highlight specific paths in the network. Below we calculate the shortest path length.

```{r}
# It will only find the shortest path for one node listed in the from field
# However if you list multiple to nodes, it will find shortest paths for each of those nodes
news_path <- shortest_paths(net,
                            from = V(net)[media == "MSNBC"],
                            to = V(net)[media == "New York Post" | media == "NY Times"],
                            output = "both") # return nodes and edges

# Generate edge colors
edge_color <- rep("gray80", ecount(net))
edge_color[unlist(news_path$epath)] <- "orange"

# Generate edge weights
edge_weights <- rep(2, ecount(net))
edge_weights[unlist(news_path$epath)] <- 4

# Generate node color
node_color <- rep("gray40", vcount(net))
node_color[unlist(news_path$vpath)] <- "gold"

plot(net, vertex.color = node_color, edge.color = edge_color, 
     edge.width = edge_weights, edge.arrow.mode = 0)
```

We can also highlight edges going into or out of a vertex.

```{r}
inc_edges <- incident(net, V(net)[media == "Wall Street Journal"], mode = "all")

# Set edges colors
edge_color <- rep("gray80", ecount(net))
edge_color[inc_edges] <- "orange"

# Set vertex colors
node_color <- rep("gray40", vcount(net))
node_color[V(net)$media == "Wall Street Journal"] <- "gold"

plot(net, vertex.color = node_color, edge.color = edge_color, edge.arrow.size = 0.2)

# Joe playing around
# How would you color every incident vertex?
inc_vertices <- unique(as.vector(get.edges(net, inc_edges)))
node_color <- rep("gray40", vcount(net))
node_color[inc_vertices] <- "gold"

plot(net, vertex.color = node_color, edge.color = edge_color, edge.arrow.size = 0.2)

# An easier way is now illustrated
# Find all nodes one step out from the focal actor
neigh_nodes <- neighbors(net, V(net)[media == "Wall Street Journal"], mode = "out")

# We can use this function to find the neighbors of multiple nodes
neigh_nodes2 <- adjacent_vertices(net, V(net)[media == "Wall Street Journal" | media == "NY Times"], mode = "out")

# We can use this function to find nodes more than one step out.
neigh_nodes3 <- ego(net, order = 2, nodes = V(net)[media == "Wall Street Journal" | media == "NY Times"], mode = "out")

node_color <- rep("gray40", vcount(net))
node_color[V(net)$media == "Wall Street Journal"] <- "gold"
node_color[neigh_nodes] <- "#ff9d00"
plot(net, vertex.color = node_color, edge.arrow.size = 0.2)

# We can also highlight groups by marking them (in this case, it is arbitrary)
plot(net, mark.groups = list(c(1, 4, 5, 8), c(15:17)),
     mark.col = c("#C5E5E7","#ECD89A"), mark.border = NA)
```

### Interactive plotting

Note that the plot must be open when you run the tkplot.getcoords() function.

```{r}
tkid <- tkplot(net)
l <- tkplot.getcoords(tkid) # Grab the coordinates from our customization
plot(net, layout = l)
```

### Plotting 2-mode networks

```{r}
V(net2)$color[V(net2)$type] <- "orange"
V(net2)$color[!V(net2)$type] <- "steel blue"

V(net2)$shape[V(net2)$type] <- "circle"
V(net2)$shape[!V(net2)$type] <- "square"

V(net2)$label[V(net2)$type] <- ""
V(net2)$label[!V(net2)$type] <- nodes2$media[!V(net2)$type]

V(net2)$label.cex = 0.6
V(net2)$label.font = 2

plot(net2, vertex.label.color = "white", vertex.size = (2 - V(net2)$type) * 8)

# Sometimes it can be useful to visualize the nodes as text
plot(net2, vertex.label = nodes$media, vertex.label.color = V(net2)$color,
     vertex.shape = "none")
```

We can also generate and plot bipartite projections. What are bipartite projections? You typically project the graph onto one of the two node sets. After projecting, the graph is constructed so it only contains nodes from that set. In our example, it will only contain nodes from the consumers or media producers categories. The resulting graph is one such that it only contains nodes from one of the categories and edges between nodes exist because they share a connection with a node from the other set.

We can also calculate weighted projections.

```{r}
net2_bp <- bipartite.projection(net2)

plot(net2_bp$proj1, vertex.label.color = "black", vertex.label.dist = 1)
plot(net2_bp$proj2, vertex.label.color = "black", vertex.label.dist = 1,
     vertex.label = nodes2$media[is.na(nodes2$media.type)])
```

### Multiplex networks

A multiplex network is one in which multiple types of ties can exist between nodes. When it comes to visualizing these connections, it can get messy very quickly particularly if the ties overlap. One useful function to help settle these issues is `r curve.multiple`. This function is able to optimally bend the curves so they all appear visible.

```{r}
multigtr <- graph(edges = c(1, 2, 1, 2, 1, 2), n = 2)
l <- layout_with_kk(multigtr)

plot(multigtr, vertex.color = "lightsteelblue", vertex.frame.color = "white", 
     vertex.size = 40, vertex.shape = "circle", vertex.label = NA,
     edge.color = c("gold", "tomato", "yellowgreen"), edge.width = 5,
     edge.arrow.size = 3, edge.curved = curve_multiple(multigtr), layout = l)
```

## Plotting graphs using other packages

### network package

Another popular package for visualizing graphs is the network package. The notation is different and some slight other differences, but the packages are largely otherwise pretty similar.

As in igraph, we can generate a *network* object from an edge list, an adjacency matrix, or an incidence matrix. One specific thing to pay attention to here is the ignore.eval parameter. It is set to TRUE by default, and that setting causes the network object to disregard edge weights.

Incidence matrices are usually used to represent two-mode or bipartite graphs (the resulting matrix representation does not necessarily have to be a square matrix). Adjacency matrices are always square since they are always one-mode.

```{r}
library(network)

net3 <- network(links, vertex.attr = nodes, matrix.type = "edgelist", loops = T,
                multiple = F, ignore.eval = F)

# We access elements of the graph similar to how we would access them in igraph
net3[,]

# To get and set attributes of the network
net3 %n% "net.name" <- "Media Network"

# To get and set attributes of the nodes
net3 %v% "media"

# To get and set attributes of the edges
net3 %e% "type"
```

Let's plot a graph using the network package.

```{r}
# Set the color attribute for nodes based on their media type
net3 %v% "col" <- c("gray70", "tomato", "gold")[net3 %v% "media.type"]

# You only need to use the %v% syntax when doing operations.
# technically do not need it for vertex.col.
plot(net3,
     vertex.cex = (net3 %v% "audience.size") / 7,
     vertex.col = net3 %v% "col")

# A plot returns coordinates which you can be saved to be used in other plots
l <- plot(net3, vertex.cex = (net3 %v% "audience.size") / 7, vertex.col = "col")
plot(net3, vertex.cex = (net3 %v% "audience.size") / 7, vertex.col = "col",
     coord = l)
```

You can also graph interactively

```{r}
plot(net3, vertex.cex = (net3 %v% "audience.size") / 7,
     vertex.col = "col", interactive = T)
```

### ggplot

We can use our igraph objects directly with ggplot.

```{r}
library(ggraph)

# You can have it choose colors automatically
ggraph(net, layout = "lgl") +
    geom_edge_fan(color = "gray50", width = 0.8, alpha = 0.5) +
    geom_node_point(color = V(net)$media.type, size = 8)

# Or manually
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]

ggraph(net, layout = "lgl") +
    geom_edge_fan(color = "gray50", width = 0.8, alpha = 0.5) +
    geom_node_point(color = V(net)$color, size = 8)

# But really we should be using the aes() function to do this right
# Hard to set multiple colors at once
ggraph(net, layout = "lgl") +
    geom_edge_link(aes(color = type)) +
    geom_node_point(aes(size = audience.size)) +
    geom_node_text(aes(label = media), repel = T)
```

### other ways to represent a graph

You can use a heatmap.

```{r}
# converts a graph to an adjacency matrix
# When we set sparse = F, we get a matrix filled with zeroes
netm <- as_adjacency_matrix(net, attr = "weight", sparse = F)
colnames(netm) <- V(net)$media
rownames(netm) <- V(net)$media

palf <- colorRampPalette(c("gold", "dark orange"))

# Rowv and Colv turn off the dendrograms.
# Scale = none ensures the values are not centered and scaled
# We have to reverse the order of the columns so the heatmap lines up
heatmap(netm[, 17:1], Rowv = NA, Colv = NA, col = palf(50), scale = "none")
```

You can also graph descriptive summary plots.

```{r}
deg.dist <- degree_distribution(net, mode = "all")
plot(x = 0:max(degree(net)), y = deg.dist, xlab="Degree",
     ylab="Relative Frequency")

deg.dist <- degree_distribution(net, cumulative = T, mode = "all")
plot(x = 0:max(degree(net)), y = 1 - deg.dist, xlab="Degree",
     ylab="Cumulative Frequency")
```

### Interactive plots using Javascript

The tutorial has a few more examples of the cool things you can do. I am also tired and do not feel like going through the rest of the interactive network visualizations.

```{r}
library(visNetwork)
visNetwork(nodes, links)

vis.nodes <- nodes
vis.links <- links

vis.nodes$shape  <- "dot"  
vis.nodes$shadow <- TRUE # Nodes will drop shadow
vis.nodes$title  <- vis.nodes$media # Text on click
vis.nodes$label  <- vis.nodes$type.label # Node label
vis.nodes$size   <- vis.nodes$audience.size # Node size
vis.nodes$borderWidth <- 2 # Node border width

vis.nodes$color.background <- c("slategrey", "tomato", "gold")[nodes$media.type]
vis.nodes$color.border <- "black"
vis.nodes$color.highlight.background <- "orange"
vis.nodes$color.highlight.border <- "darkred"

visNetwork(vis.nodes, vis.links)
```

